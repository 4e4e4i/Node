# Node.js серверный JavaScript

Содержание:

* [Теория Node.js](#NodeTheory)

## Теория Node.js <a name="NodeTheory"></a>

Версии Node.js

![](./pics/node_1.png)

Патч-версия - фиксирование багов.

Минорная версия - кроме фиксирования багов, обновление функционала (могут добавляться апи функции, переписываться внутреняя
реализация чего-то и тд), но минорная версия всегда подразумевает под собой совместимость с предыдущей версией.

Мажорная версия - полное переделывание вашего интерфейса, добавление функционала, запрещение какого-то функционала, 
добавление / удаление каких-то функций в коде и тд, обычно явная переделка.

Пример простейшего Hello World на ноде, создание сервера:

![](./pics/node_2.png)

Сама нода, она асинхронна. Обработку всех событий, которые происходят (обращения к серверу и тд), всегда будет выполняться
через колбэк или промисы. 

### Архитектура Node.js
![](./pics/node_3.png)

Глубоко внутри, у нас находятся модули на C++ (Node.js Bindings (привязки)), есть ядро библиотеки, написанное на JS,
есть библиотека libuv на языке С, которая отвечает за кросс-платформенные асинхронные запросы ввода/вывода для работы с 
файлами (потому что они разные под маком, под юниксом, под виндос), ну и, конечно, основа - движок V8. 

### Как функционирует Node.js

![](./pics/node_4.png)

Нода сама по себе однопоточна. Есть свои преимущества посравнению с многопоточностью. У нее есть так называемый один поток
Event Loop, где она постоянно проводит опросы (приходит от пользователя request, мы их опрашиваем, на операции назначаем
обработчики и делегируем нашей библиотеке libuv (non-blocking Input/output), мы туда их перебрасываем и получается мы постоянно
работаем и не останавливаемся, нет никаких блокирующих операций (ждем пока база данных ответит, файловая система и тд, что-то из
них ответит и вернет нам назад ответ, как только он возвращается назад, мы пользователю возвращаем результат).)
 
Про недостаток ноды говорят, что она одноядерная и если у нас есть четырех-ядерный сервер, то Node всегда занимает одно ядро.
Поэтому внутри есть модуль-кластерс, который позволяет одно наше приложение распараллелить на четыре этих ядра. Мы можем
сделать так, что у нас одновременно работает четыре наших приложения, а пользователь когда заправляет Request даже не
не знает на какое приложение Event Loop он попал.   

Сама схема работы Ноды, использует за основу шаблон Реактор

![](./pics/node_5.png)

Шаблон Реактор сам по себе работает в таком плане: 

![](./pics/node_6.png)

* В самом вверху нас есть приложение, так же есть какие-то запросы Ввода/Вывода и затем мы какую-то операцию Ввода/Вывода
отправляем в Демультиплексор событий
* Демультиплексор событий - это в операционной системе (за нее отвечает libuv библиотека, которая как мы раньше говорили
кросс-платформенная, под юниксом она например эмулирует асихонронность), она выделяет какой-то ресурс, операцию и обработчик.
Обработчик - это как раз наша колбэк функция, которая должна выполнится после того как операция закончится. Т.е
мы отправляем демультиплексору событий запрос и ждем, когда он нам что-то там ответи, он  выполняет операцию, наше приложение
продолжает работать (мы как бы отправили запрос и сразу вернулись в приложение (пунктирная линия на картинке)), после того
как мы завершим, мы генерируем событие, что мы закончили работу с ресурсом каким-то (базой данных, файловых системой и тд)
и помещаем в очередь событий на (2) операции наш обработчик. 
* Затем на операции (3), пока наш цикл событий постоянно что-то опрашивает, происходит обход элементов в очереди событий, для
каждого события вызывается обработчик (4), после того как обработчик возвращает после обработки, он возвращает управление
циклу событий (5а), но ситуации бывают разные, мы можем внутри нашего обработчика вызвать еще раз асинхронную операцию (5б)
и все пойдет снова по нашей схеме.
* В цикле события Node все время что-то опрашивает. После того как Цикл событий произошел (6) переходит на демультиплексор
событий, он выполняется и снова по схеме с пункта (2)

### Почему же выбирают Node.js?

![](./pics/node_7.png)

Ответы разработчиков Node.js:

* Node.js очкень эффективен, позволяя мне быть очень продуктивным
* Легкая разработка в enterprise, плюс 400 тыс. npm packages.
* Front-end, back-end и тестер имеют одинаковый язык для работы.
* Я могу развиваться и быть продуктивным во всех стеках без необходимости манирулировать другим снитаксисом.
* Тот же язык на клиенте и сервер; js способствует функциональному программированию; Typescript хорошо работает с Node.js.
* Скорость, доступность, набор инструментов. Прекрасный, как глоток свежего воздуха по сравнению с php.
* Так легко писать код в Node.js. Вы можете читать его, как любой человеческий язык.




